package main

import (
	"bytes"
	"crypto/sha256"
	"encoding/hex"
	"fmt"
	"io"
	"net/http"
	"strings"
	"text/template"

	"github.com/google/go-github/v49/github"
	log "github.com/sirupsen/logrus"
	"golang.org/x/text/cases"
	"golang.org/x/text/language"
)

type Platform string

const (
	Mac     Platform = "macos"
	Linux   Platform = "linux"
	Windows Platform = "windows"
)

type Arch string

const (
	ARM Arch = "arm"
	AMD Arch = "amd"
)

type Bits string

const (
	Six  Bits = "64"
	Five Bits = "32"
)

type Distro struct {
	Platform      Platform
	Arch          Arch
	Bits          Bits
	PayloadURL    string
	PayloadSHA256 string
	BinaryName    string
	BinaryRename  string
}

type Formula struct {
	Name           string
	Desc           string
	HomeURL        string
	Version        string
	MacOSDistros   []*Distro
	LinuxDistros   []*Distro
	WindowsDistros []*Distro
}

func (formula *Formula) Render() ([]byte, error) {
	tmplText := `
# typed: false
# frozen_string_literal: true
# This file was generated by gitall.
class {{.Name}} < Formula
  desc "{{.Desc}}"
  homepage "{{.HomeURL}}"
  version "{{.Version}}"

  on_macos do
    {{- range .MacOSDistros }}

    {{if and (eq .Arch "arm") (eq .Bits "64") -}} if Hardware::CPU.arm? && Hardware::CPU.is_64_bit?  {{- end -}}
    {{- if and (eq .Arch "arm") (ne .Bits "64") -}} if Hardware::CPU.arm?  {{- end -}}
    {{- if and (eq .Arch "amd") (eq .Bits "64") -}} if Hardware::CPU.intel? && Hardware::CPU.is_64_bit?  {{- end -}}
    {{- if and (eq .Arch "amd") (ne .Bits "64") -}} if Hardware::CPU.intel?  {{- end }}
      url "{{.PayloadURL}}"
      sha256 "{{.PayloadSHA256}}"

      def install
        bin.install "{{.BinaryName}}" => "{{.BinaryRename}}"
      end
    end{{end}}

  end

  on_linux do
    {{- range .LinuxDistros }}

    {{if and (eq .Arch "arm") (eq .Bits "64") -}} if Hardware::CPU.arm? && Hardware::CPU.is_64_bit?  {{- end -}}
    {{- if and (eq .Arch "arm") (ne .Bits "64") -}} if Hardware::CPU.arm?  {{- end -}}
    {{- if and (eq .Arch "amd") (eq .Bits "64") -}} if Hardware::CPU.intel? && Hardware::CPU.is_64_bit?  {{- end -}}
    {{- if and (eq .Arch "amd") (ne .Bits "64") -}} if Hardware::CPU.intel?  {{- end }}
      url "{{.PayloadURL}}"
      sha256 "{{.PayloadSHA256}}"

      def install
        bin.install "{{.BinaryName}}" => "{{.BinaryRename}}"
      end
    end{{end}}

  end
end
`

	tmpl, err := template.New("Brew Tap Formula").Parse(tmplText)
	if err != nil {
		return nil, err
	}

	buf := bytes.NewBuffer(nil)
	err = tmpl.Execute(buf, formula)
	if err != nil {
		return nil, err
	}

	return buf.Bytes(), nil
}

func FormulaNew(binaryName, homeURL, version string, assets []*github.ReleaseAsset) (*Formula, error) {
	log.Warnf("creating brew tap formula for %s", homeURL)

	// prepare the homebrew formula
	caser := cases.Title(language.English)
	formula := &Formula{
		Name:           caser.String(binaryName),
		HomeURL:        homeURL,
		Version:        strings.TrimPrefix(version, "v"),
		MacOSDistros:   make([]*Distro, 0),
		LinuxDistros:   make([]*Distro, 0),
		WindowsDistros: make([]*Distro, 0),
	}

	for _, asset := range assets {
		distro := &Distro{}

		name := asset.GetName()
		distro.BinaryName = strings.TrimSuffix(name, ".tar.gz")
		distro.BinaryRename = binaryName
		distro.PayloadURL = asset.GetBrowserDownloadURL()

		if strings.Contains(name, "darwin") {
			distro.Platform = Mac
			formula.MacOSDistros = append(formula.MacOSDistros, distro)
		} else if strings.Contains(name, "linux") {
			distro.Platform = Linux
			formula.LinuxDistros = append(formula.LinuxDistros, distro)
		} else if strings.Contains(name, "windows") {
			distro.Platform = Windows
			formula.WindowsDistros = append(formula.WindowsDistros, distro)
		}

		if strings.Contains(name, "-amd64.") {
			distro.Arch = AMD
			distro.Bits = Six
		} else if strings.Contains(name, "-amd.") {
			distro.Arch = AMD
			distro.Bits = Five
		} else if strings.Contains(name, "-arm64.") {
			distro.Arch = ARM
			distro.Bits = Six
		} else if strings.Contains(name, "-arm.") {
			distro.Arch = ARM
			distro.Bits = Five
		}

		// get content of file
		log.Warnf("downloading %s", distro.PayloadURL)
		resp, err := http.Get(distro.PayloadURL)
		if err != nil {
			return nil, fmt.Errorf("could not download %s: %v", distro.PayloadURL, err)
		}
		defer resp.Body.Close()

		// read the response
		buf := bytes.NewBuffer(nil)
		_, err = io.Copy(buf, resp.Body)
		if err != nil {
			return nil, fmt.Errorf("could not copy data from %s: %v", distro.PayloadURL, err)
		}

		// generate a sha
		hasher := sha256.New()
		hasher.Write(buf.Bytes())
		if err != nil {
			log.Fatal(err)
		}
		distro.PayloadSHA256 = hex.EncodeToString(hasher.Sum(nil))
	}

	return formula, nil
}

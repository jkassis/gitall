package main

import (
	"bytes"
	"crypto/sha256"
	"encoding/hex"
	"fmt"
	"html/template"
	"io"
	"net/http"
	"strings"

	"github.com/google/go-github/v49/github"
	log "github.com/sirupsen/logrus"
)

type Platform string

const (
	Mac     Platform = "macos"
	Linux   Platform = "linux"
	Windows Platform = "windows"
)

type Arch string

const (
	ARM Arch = "arm"
	AMD Arch = "amd"
)

type Bits string

const (
	Six  Bits = "64"
	Five Bits = "32"
)

type Distro struct {
	Platform      Platform
	Arch          Arch
	Bits          Bits
	PayloadURL    string
	PayloadSHA256 string
	BinaryName    string
	BinaryRename  string
}

type Formula struct {
	HomeURL        string
	Version        string
	MacOSDistros   []*Distro
	LinuxDistros   []*Distro
	WindowsDistros []*Distro
}

func (formula *Formula) Render() ([]byte, error) {
	tmplText := `
# typed: false
# frozen_string_literal: true
# This file was generated by gitall.
class Gitall < Formula
  desc ""
  homepage "{{.HomeURL}}"
  version "{{.Version}}"

  on_macos do
	  {{ range .MacOSDistros }}
		{{ if eq .Arch "arm" and eq .Bits "64" }}
    if Hardware::CPU.arm? && Hardware::CPU.is_64_bit?
		{{ end }}
		{{ if eq .Arch "arm" and ne .Bits "64" }}
    if Hardware::CPU.arm?
		{{ end }}

		{{ if eq .Arch "amd" and eq .Bits "64" }}
    if Hardware::CPU.intel? && Hardware::CPU.is_64_bit?
		{{ end }}
		{{ if eq .Arch "amd" and ne .Bits "64" }}
    if Hardware::CPU.intel?
		{{ end }}

      url ".PayloadURL"
      sha256 ".PayloadSHA256"

      def install
        bin.install "{{.BinaryName}}" => "{{.BinaryRename}}
      end
    end
		{{ end }}
  end

  on_linux do
	  {{ range .LinuxDistros }}
		{{ if eq .Arch "arm" and eq .Bits "64" }}
    if Hardware::CPU.arm? && Hardware::CPU.is_64_bit?
		{{ end }}
		{{ if eq .Arch "arm" and ne .Bits "64" }}
    if Hardware::CPU.arm?
		{{ end }}

		{{ if eq .Arch "amd" and eq .Bits "64" }}
    if Hardware::CPU.intel? && Hardware::CPU.is_64_bit?
		{{ end }}
		{{ if eq .Arch "amd" and ne .Bits "64" }}
    if Hardware::CPU.intel?
		{{ end }}

      url ".PayloadURL"
      sha256 ".PayloadSHA256"

      def install
        bin.install "{{.BinaryName}}" => "{{.BinaryRename}}
      end
    end
		{{ end }}
  end
end
`

	tmpl, err := template.New("Brew Tap Formula").Parse(tmplText)
	if err != nil {
		return nil, err
	}

	buf := bytes.NewBuffer(nil)
	err = tmpl.Execute(buf, formula)
	if err != nil {
		return nil, err
	}

	return buf.Bytes(), nil
}

func FormulaNew(binaryName, repoURL, version string, assets []*github.ReleaseAsset) (*Formula, error) {
	log.Warnf("creating brew tap formula for %s", repoURL)

	// prepare the homebre formula
	formula := &Formula{
		HomeURL:        repoURL,
		Version:        version,
		MacOSDistros:   make([]*Distro, 0),
		LinuxDistros:   make([]*Distro, 0),
		WindowsDistros: make([]*Distro, 0),
	}

	for _, asset := range assets {
		distro := &Distro{}

		name := asset.GetName()
		distro.BinaryName = name
		distro.BinaryRename = binaryName
		distro.PayloadURL = asset.GetBrowserDownloadURL()

		if strings.Contains(name, "darwin") {
			distro.Platform = Mac
			formula.MacOSDistros = append(formula.MacOSDistros, distro)
		} else if strings.Contains(name, "linux") {
			distro.Platform = Linux
			formula.LinuxDistros = append(formula.LinuxDistros, distro)
		} else if strings.Contains(name, "windows") {
			distro.Platform = Windows
			formula.WindowsDistros = append(formula.WindowsDistros, distro)
		}

		if strings.Contains(name, "-amd64.") {
			distro.Arch = AMD
			distro.Bits = Six
		} else if strings.Contains(name, "-amd.") {
			distro.Arch = AMD
			distro.Bits = Five
		} else if strings.Contains(name, "-arm64.") {
			distro.Arch = ARM
			distro.Bits = Six
		} else if strings.Contains(name, "-arm.") {
			distro.Arch = ARM
			distro.Bits = Five
		}

		// get content of file
		log.Warnf("downloading %s", distro.PayloadURL)
		resp, err := http.Get(distro.PayloadURL)
		if err != nil {
			return nil, fmt.Errorf("could not download %s: %v", distro.PayloadURL, err)
		}
		defer resp.Body.Close()

		// read the response
		buf := bytes.NewBuffer(nil)
		_, err = io.Copy(buf, resp.Body)
		if err != nil {
			return nil, fmt.Errorf("could not copy data from %s: %v", distro.PayloadURL, err)
		}

		// generate a sha
		hasher := sha256.New()
		hasher.Write(buf.Bytes())
		if err != nil {
			log.Fatal(err)
		}
		distro.PayloadSHA256 = hex.EncodeToString(hasher.Sum(nil))
	}

	return formula, nil
}
